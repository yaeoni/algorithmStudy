"""
Q) 캐릭터가 처음 걸어본 길의 길이
- 좌표 경계 넘어가는건 PASS(5*5->-5,5)

------------ 첫번째 생각 -----------
- 좌표를 싹 양수로 만들자 5*5에 경계 : (0,10), (0,0), (10, 0), (10,10) / 중간 : (5,5)
- 지나온 길을 표시하는 visited[] 정의 -> if not in 인 경우에만 answer +=1
  ~ 아니? 굳이 배열 만들 필요도 없음. 좌표값을 바꾸면 되지
  
 
에러) *좌표 기준이라서, 들렸던 좌표면 이제 간 길인지 안 간 길인지 분간이 안간다*
    => 방향도 같이 생각을 해줘야하는거였음!! 우하!!, 같이 저장을 해줄까싶은데 배열에,
    아니 방향값만 참고하는 배열을 만들어주면 되징.
     방향값 참고[x][y][d] 의 배열 만드는 거에서 삑나고 잇음 . 뭔가 배열을 잘못만든거야. 방향값까지포함하는 배열을 // 암튼 잘못만듬 담에 확인!! 12시임!
    
----------- 검색즈 ----------
- 좌표와 방향까지 고려해야한다는 것은 맞았는데, 출발-도착 지점으로 저장해서 간선 구분한다는게 안되었다.
=> 내가 만든(안됐지만) 방향까지 고려한 배열이 안되는게, 출발 <-> 도착은 서로 반대여도 같은 간선이라는점!

에러) 좌표는 0~10으로 옮겨도, (0,10)까지는 참조 가능했어야 했다. 애초애 0~11로 뒀어야 했고, 기존에 배열 선언했던건 도대체 왜 틀렸을까? 근데 어차피 틀렸ㅇ을거긴하다.
출발과 도착지점이 바뀐 경우가 카운트가 안될거니까.
"""
def getDir(dir):
    # 위
    if(dir=="U"):
        return 0,1
    # 아래
    elif(dir=="D"):
        return 0,-1
    elif(dir=="R"):
        return 1,0
    else:
        return -1,0
    
def solution(dirs):
    answer = 0
    map = [[0]*10 for _ in range(10)]
    
    # 중복 방지 -> set 함수 활용
    edges = set()
    x,y = 5, 5
    
    for idx, dir in enumerate(dirs):
        nx, ny = getDir(dir)
        #print("nx,ny", nx, ny)
        newX, newY = x+nx, y+ny
        #print("newX, newY, dir",newX-5, newY-5)
        
        if(0 > newX or 11 <= newX or 0 > newY or 11 <= newY):
            continue
        else:
            # 출발 도착지가 서로 바뀌어도 같은 간선 -> 그냥 2 가지 경우 다 넣어버리고 2로 나눠주면댐
            edges.add((x, y, newX, newY))
            edges.add((newX, newY, x, y))
            x = newX
            y = newY
            
            
    return len(edges)/2