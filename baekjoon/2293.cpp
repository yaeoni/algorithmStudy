/*
- n가지 동전 -> 적당히 사용해 가치의 합이 k 가 되도록.
- 가능한 모든 경우의 수를 사용
- 각 동전은 여러번 사용도 가능하다

- dp 포인트는 동전의 합을 구하는게 반복된다는거.
- 이걸 어떻게 저장을 해놔야할지 잘 모르겠는걸

[답 오잉 어케 이렇게 생각했디야..]
- dp[k] : 가치 k를 만들 수 있는 가지 수
- 현재 X원인 동전을 가지고 있고, 이 동전을 이용해 Y원을 만들고 싶다면
    - DP[Y] = DP[Y] + DP[Y-X] 
    - 동전이 가지고 있는 가치만큼을 뺀 나머지 액수를 만드는 경우의 수가 더해진다는 것.

- if) {1, 2, 3} 이고 3원을 만든다면
    - 3원 이용 시 -> dp[3] += dp[0] : 0원을 만들 수 있는 상황에서 바로 3원 사용
    - 2원 이용 시 -> dp[3] += dp[1] : 기존에 1원을 가지고 있고, 2원 추가.
    - 1원 이용 시 -> dp[3] += dp[2] : 기존에 2원을 가지고 있고, 1원 추가.

- 0 원을 만들 수 있는 경우 => 1가지. (dp[0] = 1)
- 내가 x원을 이용해 만들 수 있는 금액은 최소 x보다 같거나 커야함. 와우.
- 진정한 이해는 점화식을 세움으로서 진행해야한다.. ㅠ 윽 어려워

*/
#include <iostream>

using namespace std;

int n;
int k;
int arr[101];
int dp[100001]; // 항상 자동으로 0으로 initialize 된다네.

int main(void){
    cin.tie(NULL);
    ios::sync_with_stdio(false);

    cin >> n >> k;
    
    for(int i = 1 ; i <= n ; i++) cin >> arr[i];
    
    dp[0] = 1;
    for(int i = 1 ; i <= n ;i++){
        for(int j = arr[i] ; j <= k ; j++){       
            dp[j] = dp[j] + dp[j-arr[i]];
        }
    }
    cout << dp[k] << "\n";
    return 0;
}